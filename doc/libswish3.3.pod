=pod

=head1 NAME

libswish3 - Swish3 C library

=head1 SYNOPSIS


=head2 Data structures

 struct swish_StringList
 {
     int             n;
     xmlChar **      word;
 };

 struct swish_Config
 {
    unsigned int    ref_cnt;    /* for scripting languages */
    void *          stash;      /* also for scripting languages */
    xmlHashTablePtr conf;       /* the meat */
 };


 struct swish_DocInfo
 {
     time_t         mtime;
     off_t          size;
     xmlChar *      mime;
     xmlChar *      encoding;
     xmlChar *      uri;
     unsigned int   nwords;
     xmlChar *      ext;
     xmlChar *      parser;
     xmlChar *      update;
 };
 
  
 
 struct swish_Word
 {
     unsigned int           position;       
     xmlChar *              metaname;      
     xmlChar *              word;          
     unsigned int           start_offset;   
     unsigned int           end_offset;       
     struct swish_Word *   next;          
     struct swish_Word *   prev;          
 };
 
 struct swish_WordList
 {
     swish_Word *      head;
     swish_Word *      tail;
     swish_Word *      current;        
     unsigned int       nwords;
 };
 
 struct swish_Tag
 {
     xmlChar *           name;
     struct swish_Tag * next;
     unsigned int        n;
 };
 
 struct swish_TagStack
 {
     swish_Tag *       head;
     swish_Tag *       temp;
     unsigned int       count;
     char *             name;       
     xmlChar *          flat;       
 };
 
 
 struct swish_ParseData
 {
     xmlBufferPtr          buf_ptr;            
     xmlBufferPtr          prop_buf;          
     xmlChar *             tag;                
     swish_DocInfo *       docinfo;            
     xmlHashTablePtr       config;             
     unsigned int          is_html;            
     unsigned int          word_pos;           
     unsigned int          offset;             
     unsigned int          parsewords;         
     unsigned int          maxwordlen;         
     unsigned int          minwordlen;         
     unsigned int          bump_word;          
     swish_TagStack *      metastack;          
     swish_TagStack *      propstack;          
     xmlParserCtxtPtr      ctxt;
     swish_WordList *      wordlist;           
     xmlHashTablePtr       propHash;
     swish_WordList *      word_tokenizer_func();
     void *                user_data;       
 
 };


=head2 I/O functions

 xmlChar *       swish_slurp_stdin( long flen );
 
 xmlChar *       swish_slurp_file_len( xmlChar *filename, long flen );
 
 xmlChar *       swish_slurp_file( xmlChar *filename );

=head2 String functions

 void                swish_verify_utf8_locale();
 
 int                 swish_is_ascii(xmlChar *utf8);
 
 wchar_t *           swish_locale_to_wchar(xmlChar *utf8);
 
 xmlChar *           swish_wchar_to_locale(wchar_t *ws);
 
 wchar_t *           swish_wstr_tolower(wchar_t *ws);
 
 xmlChar *           swish_str_tolower(xmlChar *utf8);
 
 xmlChar *           swish_str_skip_ws(xmlChar *utf8);
 
 void                swish_str_trim_ws(xmlChar *utf8);
 
 void                swish_debug_wchars(const wchar_t * ws);
 
 int                 swish_wchar_t_comp(const void *ws1, const void *ws2);
 
 int                 swish_sort_wchar(wchar_t *ws);
 
 swish_StringList *  swish_make_StringList(xmlChar *utf8);
 
 swish_StringList *  swish_init_StringList();
 
 void                swish_free_StringList(swish_StringList *list);

=head2 Memory functions

 void        swish_init_memory();
 
 void *      swish_xrealloc(void *ptr, size_t size);
 
 void *      swish_xmalloc( size_t size );
 
 void        swish_xfree( void *ptr );
 
 void        swish_mem_debug();
 
 xmlChar *   swish_xstrdup( const xmlChar * ptr );


=head2 Hash functions

 int     swish_hash_add( xmlHashTablePtr hash, 
                          xmlChar *key, 
                          void * value );
 
 int     swish_hash_replace( xmlHashTablePtr hash, 
                              xmlChar *key, 
                              void *value );
                                    
 int     swish_hash_delete( xmlHashTablePtr hash, 
                             xmlChar *key );

=head2 Time functions

 double  swish_time_elapsed(void);
 
 double  swish_time_cpu(void);
 
 char *  swish_print_time(double time);
 

=head2 Error functions

 void swish_set_error_handle( FILE *where );
 
 void swish_fatal_err(char *msg,...);
 
 void swish_warn_err(char *msg,...);
 
 void swish_debug_msg(char *msg,...);


=head2 Config functions

 swish_Config *  swish_init_config();
 
 swish_Config *  swish_add_config( 
                            xmlChar * conf, 
                            swish_Config * config );
 
 void            swish_debug_config( swish_Config * config );
 
 xmlHashTablePtr swish_subconfig_hash( swish_Config * config, 
                                        xmlChar *key);
 
 int             swish_config_value_exists( 
                                        swish_Config * config, 
                                        xmlChar *key, 
                                        xmlChar *value );
                                        
 xmlChar *       swish_get_config_value(
                                        swish_Config * config, 
                                        xmlChar * key, 
                                        xmlChar * value);
                                        
 void            swish_free_config( swish_Config * config );
 
 xmlHashTablePtr swish_mime_hash();
 
 xmlChar *       swish_get_mime_type(  swish_Config * config, 
                                        xmlChar * fileext );
  
 xmlChar *       swish_get_parser( swish_Config * config, 
                                    xmlChar *mime );


=head2 Parser functions

 void swish_init_parser();
 
 void swish_free_parser();
 
 int swish_parse_file(      xmlChar *filename, 
                            xmlHashTablePtr config, 
                            void (*func)(swish_ParseData*),
                            swish_WordList* (*word_tokenizer) 
                                                (xmlChar* string, 
                                                xmlChar* metaname, 
                                                int maxwordlen, 
                                                int minwordlen, 
                                                int word_pos, 
                                                int offset) 
                            );
                        
 int swish_parse_stdin(     xmlHashTablePtr config, 
                            void (*func)(swish_ParseData*),
                            swish_WordList* (*word_tokenizer) 
                                                (xmlChar* string, 
                                                xmlChar* metaname, 
                                                int maxwordlen, 
                                                int minwordlen, 
                                                int word_pos, 
                                                int offset) 
                            );
                            
 int swish_parse_buffer(    xmlChar * buf, 
                            xmlHashTablePtr config, 
                            void (*func)(swish_ParseData*),
                            swish_WordList* (*word_tokenizer) 
                                                (xmlChar* string, 
                                                xmlChar* metaname, 
                                                int maxwordlen, 
                                                int minwordlen, 
                                                int word_pos, 
                                                int offset) 
                            );



=head2 xmlBuffer functions

 void               swish_append_buffer(  xmlBufferPtr ptr, 
                                          const xmlChar * txt, 
                                          int txtlen);


=head2 WordList functions

 swish_WordList *   swish_init_WordList();
 
 void               swish_free_WordList(      swish_WordList * list);
 
 swish_WordList *   swish_string_to_words(    xmlChar * str, 
                                              xmlChar * metaname, 
                                              int maxwordlen, 
                                              int minwordlen, 
                                              int base_word_pos, 
                                              int offset );
                                                
 size_t             swish_add_to_wordlist(    swish_WordList * list, 
                                              wchar_t * word, 
                                              int word_len, 
                                              xmlChar * metaname, 
                                              int word_pos, 
                                              int offset );
                                                
 void               swish_debug_wordlist( swish_WordList * list );


=head2 DocInfo functions

 swish_DocInfo *     swish_init_docinfo();
 
 void                swish_free_docinfo(   swish_DocInfo * ptr );
 
 int                 swish_check_docinfo(  swish_DocInfo * docinfo, 
                                           xmlHashTablePtr config);
                                            
 int                 swish_docinfo_from_filesystem( 
                                    xmlChar * filename, 
                                    swish_DocInfo * i, 
                                    swish_ParseData * parse_data );

 void                swish_debug_docinfo( swish_DocInfo * docinfo );

 xmlChar *           swish_get_file_ext( xmlChar * url );

=head2 Property functions

 xmlHashTablePtr swish_init_PropHash( xmlHashTablePtr config);
 
 void            swish_free_PropHash( xmlHashTablePtr prophash);
 
 void            swish_debug_PropHash(xmlHashTablePtr propHash);



=head1 DESCRIPTION

B<libswish3> is the core C library of B<Swish3>.

B<libswish3> uses the GNOME B<libxml2> library to parse words and metadata 
from XML, HTML and plain text files. B<libswish3> supports full UTF-8 encoding.

B<libswish3> is a parsing tool for use with information retrieval (IR) libraries.
It is written in C. Perl bindings are available on CPAN as B<SWISH::Parser>.

=head1 APIs

The following APIs are defined:

=head1 Parsing API

B<libswish3> provides three basic input functions:

=over

=item

swish_parse_file()

=item

swish_parse_stdin()

=item

swish_parse_buffer()

=back

Each of these functions takes a C<swish_Config> struct pointer,
a I<handler> function pointer, and an optional I<word_tokenizer> function
pointer.

In addition:

=over

=item

The swish_parse_file() function takes a file path, which must be a valid file.
Directories and links are not supported. The assumption is that you will use
your calling code to recurse through directories and handle links.

=item

swish_parse_buffer() takes a string representing the document
headers and the full text of the document.

=back

See the L<Headers API> section for more
information on using swish_parse_stdin() and
swish_parse_buffer().

The I<handler> function is called after a document is completely parsed.
The I<handler> function will receive one argument:
the B<swish_ParseData> struct object, which contains all the words, metadata, and 
properties for the document.
After the I<handler> is called, all allocated memory in the B<swish_ParseData>
struct is freed automatically.

The I<handler> function allows you to store extracted words and document properties
in an index or database. See the L<Structures API> section for details of the 
B<swish_ParseData> struct.

The optional I<word_tokenizer> function allows you to override the default
method libswish3 uses for parsing a string of characters into a list of word tokens.
If you wish to use the default word parser, just pass B<NULL> as the I<word_tokenizer>
value.


=head1 Headers API

The Headers API supports and extends the Swish-e B<-S prog> feature, 
which allows you to feed the indexer with output from another I<prog>ram. 
The API has been extended from Swish-e's to allow for MIME types 
and more congruence with the HTTP 1.1 specification. 

See SWISH-RUN documentation
in the Swish-e distribution for the Swish-e version 2 headers API.

This is the libswish3 implementation. See B<SWISH::Prog::Headers> for a simple
Perl-based way of generating the proper headers.

=over

=item Content-Location

B<Swish-e name:> Path-Name

The name of the document. May be any string: an ID of a record in a database, 
a URL or a simple file name. The string is stored in the swish_DocInfo B<uri> struct member, 
which is often used as the primary identifier of a document in an index.

This header is required.

=item Content-Length

The length in bytes of the document, starting after the blank line separating the headers
from the document itself.
The value must be exactly the length of the document, including any extra
line feeds or carriage returns at the end of the document.

Example:

 Content-Location: foo.html
 Content-Length: 9

 The doc.\n
 ^^^^^^^^ ^
 12345678 9

The value is stored in the swish_DocInfo B<size> struct member.

This header is required.


=item Last-Modified

B<Swish-e name:> Last-Mtime

The last modification time of the document. The value must be an integer:
the seconds since the Epoch on your system.

If not present, will default to the current time.

The value is stored in the swish_DocInfo B<mtime> struct member.

This header is not required.

=item Parser-Type

B<Swish-e name:> Document-Type

Explicitly name the parser used for the document, rather than defaulting to the MIME
type mapping based on B<Content-Type> and/or B<Content-Location>. The three parser types are:

=over

=item

XML

=item

HTML

=item

TXT

=back

The Swish-e values B<XML2>, B<XML*>, B<HTML2>, B<HTML*>, B<TXT2>, B<TXT*> are also
supported for compatibility, but they map to the three libswish3 types.

The value is stored in the swish_DocInfo B<parser> struct member.

If not present, the document parser will be automatically chosen based on the following logic:

=over

=item

If a B<Content-Type> is given, the parser mapped to that MIME type will be used. You may override
the default mappings in your configuration. See B<Configuration API>.

=item

If no B<Content-Type> is given, a MIME type will be guessed at based on the file extension of the
document's B<Content-Location>, and the parser mapped to that MIME type will be used.

=item

Finally, if a MIME type is not identified, the parser defined in B<SWISHP_CONFIG_DEFAULT_PARSER>
in B<libswish3.h> will be used.

=back

See also B<Content-Type> and B<Content-Location>.

This header is not required.

=item Content-Type

The MIME type of the document. The libswish3 MIME type list is based on the Apache 2.0
version. See L<http://www.iana.org/assignments/media-types/> for the official registry.

If not defined with B<Content-Type>, the MIME type will be guessed based on the 
file extension in the B<Content-Location>
header. If the B<Content-Location> string does not contain a file extension (as might be the case
with non-URL value), or the file extension has no MIME mapping, then the MIME type will default
to B<SWISHP_DEFAULT_MIME> as defined in B<libswish3.h>.

You may override the default extension-to-MIME mappings in your configuration. See B<Configuration API>.

The value is stored in the swish_DocInfo B<mime> struct member.

See also B<Content-Location> and B<Parser-Type>.

This header is not required.


=item Update-Mode

B<NOTE:> This header exists only for backwards compatibility with Swish-e's incremental
index feature. B<It may be deprecated in a future version of libswish3.>

=back



=head1 Structures API

Writing an effective I<handler> function requires an understanding of some of the key
B<libswish3> data structures.

 TODO

=head2 swish_ParseData

=head2 swish_WordList

=head2 swish_Word

=head2 swish_DocInfo


=head1 The I<handler> Function

 TODO
 

=head1 The I<word_tokenizer> Function

 TODO


=head1 EXAMPLES

See the C<swish_lint.c> file included in the libswish3 distribution.

=head1 FAQ

=head2 What is IR?

Information Retrieval.

=head2 How is libswish3 related to Swish-e?

libswish3 is the core parsing library for Swish-e version 3 (Swish3).

=head2 Is libswish3 a search engine?

No. libswish3 is a document parser. It might work well in or with any number of search engines,
but it is not in itself any kind of search tool.

=head2 So what does libswish3 DO exactly?

libswish3 reads text, HTML and XML files and extracts just the words and document
properties from each document. It then hands off the wordlist and properties
to a I<handler> function. Finally, it frees all the memory associated with the wordlist
and properties.

The I<handler> function can do whatever you wish, though typically a I<handler>
would iterate over the words in the wordlist and add each one to an index using
an IR library API.


=head1 BACKGROUND

libswish3 is part of the Swish-e project. 
It was born out of the need for UTF-8 and incremental
indexing support and a desire to experiment with alternate indexing
libraries like Lucene, KinoSearch, Xapian and Hyperestraier.

libswish3 was developed with the idea that many quality IR libraries already exist,
but few if any provide an easy and fast way of preparing documents for indexing. 
The following assumptions informed the development of libswish3.

=head2 The IR Toolchain

A decent IR toolchain requires 5 parts:

=over 4

=item aggregator

Collects documents from a filesystem, database, website or other sources.

=item filter

Normalizes documents to a standard format (plain text or a delimited/markup
like YAML, HTML or XML) for indexing.

=item parser

Breaks a document into a list of words, including their context and position.

=item indexer

Writes the list of words in a storage system for quick, efficient retrieval.

=item searcher

Parses queries and fetches data from the indexer's storage system.

=back

Of course, the division between these parts is not always clean or apparent. Parsing search
queries, for example, will necessarily involve elements of the parser and searcher
components, while the indexer and searcher are of necessity intrinsically bound.

But any complete IR system will have these five parts in some combination.

=head2 Swish-e aggregators and filters are already good

The existing Swish-e document aggregators (B<DirTree.pl> and B<spider.pl>) and filtering
system (B<SWISH::Filter>) are good. They are all written in Perl and are easily modified,
and they have ample configuration options and documentation.

=head2 Why reinvent the wheel?

Several good IR libraries exist that provide an indexer and searcher. These libraries
do UTF-8, incremental indexing, and have search syntax on par with (or better than)
Swish-e 2.x. Examples include Xapian, KinoSearch and Lucene. 
While they might be a little slower
than Swish-e (at least in terms of indexing speed) they make up that for with:

=over

=item

well-documented APIs

=item

bindings in a variety of programming languages

=item

active development communities

=item

the flexibility that comes with being a library instead of a fixed program

=back


=head2 The missing link

The piece that Swish-e provides that other IR libraries lack is a fast, stable, integrated
document parser. Xapian has Omega, but it does not parse XML, nor does it recognize
ad hoc word context (metanames).

However, the Swish-e 2.x parser does not work independently of the Swish-e indexer
and searcher, nor does it support UTF-8.

One piece is missing: a parser that works with the Swish-e aggregator/filter system, supports
UTF-8, and offers flexible options for connecting with other IR libraries.

Ergo, libswish3: a document parser compatible with the existing Swish-e -S prog API
and capable of generating UTF-8 wordlists for indexing with a variety of IR libraries.

=head2 Where does libswish3 fit?

libswish3 is the core C library in Swish3.

However, libswish3 may be used without the rest of the Swish3.
The assumption is that libswish3 could fit into an IR toolchain like this:

 aggregator -> filter -> libswish3 -> some IR library

You could then use the native search API of the IR library.

For example, you might use the Swish-e B<spider.pl> script to spider a website, filtering
documents with B<SWISH::Filter> and then handing the output to a B<libswish3>-based
program that will parse the documents into words and store the data in a 
Xapian or KinoSearch index (or both!). That model is, in fact, what Swish3 does.

Or you might use the B<SWISH::Prog> Perl module (from the CPAN) to build your own
aggregator/filter system, then hand the output to libswish3.


=head1 CREDITS

B<libswish3> is based on code from
Swish-e (http://www.swish-e.org),
libxml2 (http://www.xmlsoft.org),
Apache (http://www.apache.org),
Rahul Dhesi (http://www.tug.org/tex-archive/tools/zoo/),
Angel Ortega (http://www.triptico.com/software/unicode.html),
James Henstridge (http://www.jamesh.id.au/articles/libxml-sax/libxml-sax.html),
YoLinux (http://www.yolinux.com/TUTORIALS/GnomeLibXml2.html)
and no doubt many unnamed others.

All mistakes, errors and poor programming choices are, however, those
of the author: Peter Karman (http://peknet.com/).

=head1 LICENSE

B<libswish3> is licensed under the GPL.

libswish3 is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

libswish3 is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with libswish3; see the file COPYING.  If
not, write to the

 Free Software Foundation, Inc.
 59 Temple Place - Suite 330
 Boston, MA 02111-1307, USA

=head1 SEE ALSO

The project homepage: http://swish-e.org/swish3/

swish3(7), swish_lint(1), swish_isw(1), swish_words(1)

=cut