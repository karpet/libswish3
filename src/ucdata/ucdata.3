ucdata(3)                                                            ucdata(3)



NNAAMMEE
       ucdata - package for providing Unicode/ISO10646 character information


SSYYNNOOPPSSIISS
       #include <ucdata.h>

       void ucdata_load(char * paths, int masks)

       void ucdata_unload(int masks)

       void ucdata_reload(char * paths, int masks)

       int ucdecomp(unsigned long code, unsigned long *num,
                    unsigned long **decomp)

       int uccanondecomp(const unsigned long *in, int inlen,
                    unsigned long **out, int *outlen)

       int ucdecomp_hangul(unsigned long code,
                    unsigned long *num, unsigned long decomp[])

       int uccomp(unsigned long ch1, unsigned long ch2,
                    unsigned long *comp)

       int uccomp_hangul(unsigned long *str, int len)

       int uccanoncomp(unsigned long *str, int len)

       struct ucnumber {
         int numerator;
         int denominator;
       };

       int ucnumber_lookup(unsigned long code, struct ucnumber *num)

       int ucdigit_lookup(unsigned long code, int *digit)

       struct ucnumber ucgetnumber(unsigned long code)

       int ucgetdigit(unsigned long code)

       unsigned long uctoupper(unsigned long code)

       unsigned long uctolower(unsigned long code)

       unsigned long uctotitle(unsigned long code)

       int ucisprop(unsigned long code, unsigned long mask1,
                    unsigned long mask2)

       int uc8isprop(unsigned char *code, unsigned long mask1,
                    unsigned long mask2)

       int ucprops(unsigned long code, unsigned long mask1,
                    unsigned long mask2, unsigned long *mask1_out,
                    unsigned long *mask2_out)

       int uc8props(unsigned char *code, unsigned long mask1,
                    unsigned long mask2, unsigned long *mask1_out,
                    unsigned long *mask2_out)

       int ucisalpha(unsigned long code)

       int ucisalnum(unsigned long code)

       int ucisdigit(unsigned long code)

       int uciscntrl(unsigned long code)

       int ucisspace(unsigned long code)

       int ucisblank(unsigned long code)

       int ucispunct(unsigned long code)

       int ucisgraph(unsigned long code)

       int ucisprint(unsigned long code)

       int ucisxdigit(unsigned long code)

       int ucisupper(unsigned long code)

       int ucislower(unsigned long code)

       int ucistitle(unsigned long code)

       int uchascase(unsigned long code)

       int ucisisocntrl(unsigned long code)

       int ucisfmtcntrl(unsigned long code)

       int ucissymbol(unsigned long code)

       int ucisnumber(unsigned long code)

       int ucisnonspacing(unsigned long code)

       int ucisopenpunct(unsigned long code)

       int ucisclosepunct(unsigned long code)

       int ucisinitialpunct(unsigned long code)

       int ucisfinalpunct(unsigned long code)

       int uciscomposite(unsigned long code)

       int ucisquote(unsigned long code)

       int ucissymmetric(unsigned long code)

       int ucismirroring(unsigned long code)

       int ucisnonbreaking(unsigned long code)

       int ucisrtl(unsigned long code)

       int ucisltr(unsigned long code)

       int ucisstrong(unsigned long code)

       int ucisweak(unsigned long code)

       int ucisneutral(unsigned long code)

       int ucisseparator(unsigned long code)

       int ucislsep(unsigned long code)

       int ucispsep(unsigned long code)

       int ucismark(unsigned long code)

       int ucisnsmark(unsigned long code)

       int ucisspmark(unsigned long code)

       int ucismodif(unsigned long code)

       int ucismodifsymbol(unsigned long code)

       int ucisletnum(unsigned long code)

       int ucisconnect(unsigned long code)

       int ucisdash(unsigned long code)

       int ucismath(unsigned long code)

       int uciscurrency(unsigned long code)

       int ucisenclosing(unsigned long code)

       int ucisprivate(unsigned long code)

       int ucissurrogate(unsigned long code)

       int ucisidentstart(unsigned long code)

       int ucisidentpart(unsigned long code)

       int ucisdefined(unsigned long code)

       int ucisundefined(unsigned long code)

       int ucishan(unsigned long code)

       int ucishangul(unsigned long code)

       int ucgetutf8lower(unsigned char *upper, unsigned char **lower)

       int uctoutf8(unsigned long ch, unsigned char buf[], int bufsize)

       int uctoutf32(unsigned char utf8[], int bytes)


DDEESSCCRRIIPPTTIIOONN
       MMaaccrrooss
           UCDATA_CASE
           UCDATA_CTYPE
           UCDATA_DECOMP
           UCDATA_CMBCL
           UCDATA_NUM
           UCDATA_COMP
           UCDATA_CASECMP
           UCDATA_UC8CTYPE

           UUCCDDAATTAA__UUFFTT3322
             A combination of (UCDATA_CASE|UCDATA_CTYPE|
                               UCDATA_DECOMP|UCDATA_CMBCL
                               UCDATA_NUM|UCDATA_COMP)

           UUCCDDAATTAA__UUTTFF88
             A combination of (UCDATA_CASECMP|UCDATA_UC8CTYPE)

           UUCCDDAATTAA__AALLLL
             A combination of UUCCDDAATTAA__UUTTFF3322 and UUCCDDAATTAA__UUTTFF88.

       uuccddaattaa__llooaadd(())
           This function initializes the UCData library by locating  the  data
           files  in  one  of  the  colon-separated directories in the `paths'
           parameter.  The data files  to  be  loaded  are  specified  in  the
           `masks'  parameter  as  a  bitwise combination of the macros listed
           above.

           This should be called before using any of the other functions.

       uuccddaattaa__uunnllooaadd(())
           This function unloads the data  tables  specified  in  the  `masks'
           parameter.

           This  function  should be called when the application is done using
           the UCData package.

       uuccddaattaa__rreellooaadd(())
           This function reloads the data files from one  of  the  colon-sepa-
           rated  directories  in the `paths' parameter.  The data files to be
           reloaded are specified in the `masks' parameter as a bitwise combi-
           nation of the macros listed above.

       uuccddeeccoommpp(())
           This  function  determines  if  a character has a decomposition and
           returns the decomposition information if it exists.

           If a zero is returned, there is no decomposition.  If a non-zero is
           returned,  then the `num' and `decomp' variables are filled in with
           the appropriate values.

           Example call:

               unsigned long i, num, *decomp;

               if (ucdecomp(0x1d5, &num, &decomp) != 0) {
                  for (i = 0; i < num; i++)
                    printf("0x%08lX,", decomp[i]);
                  putchar('0);
               }

       uuccccaannoonnddeeccoommpp(())
           This function will decompose a string, insuring the characters are
           in canonical order for comparison.

           If a decomposed string is returned, the caller is responsible for
           deallocating the string.

           If a -1 is returned, memory allocation failed.  If a zero is
           returned, no decomposition was done.  Any other value means a
           decomposition string was created and the values returned in the
           `out' and `outlen' parameters.

       uuccddeeccoommpp__hhaanngguull(())
           This function determines if a Hangul syllable has a
           decomposition and returns the decomposition information.

           An array of at least size 3 should be passed to the function
           for the decomposition of the syllable.

           If a zero is returned, the character is not a Hangul
           syllable. If a non-zero is returned, the `num' field
           will be 2 or 3 and the syllable will be decomposed into
           the `decomp' array arithmetically.

           Example call:

               unsigned long i, num, decomp[3];

               if (ucdecomp_hangul(0xb1ba, &num, &decomp) != 0) {
                  for (i = 0; i < num; i++)
                    printf("0x%08lX,", decomp[i]);
                  putchar('0);
               }

       uuccccoommpp(())
           This function determines if a pair of characters have a composition,
           and returns that composition if one exists.

           A zero is returned is no composition exists for the character pair.
           Any other value indicates the `comp' field holds the character code
           representing the composition of the two character codes.

       uuccccoommpp__hhaanngguull(())
           This composes the Hangul Jamo in-place in the string.

           The returned value is the new length of the string.

       uuccccaannoonnccoommpp(())
           This function does a full composition in-place in the string,
           including the Hangul composition.

           The returned value is the new length of the string.

       uuccnnuummbbeerr__llooookkuupp(())
           This function determines if the code is a number and
           fills in the `num' field with the numerator and
           denominator.  If the code happens to be a single digit,
           the numerator and denominator fields will be the same.

           If the function returns 0, the code is not a number.
           Any other return value means the code is a number.

       uuccddiiggiitt__llooookkuupp(())
           This function determines if the code is a digit and
           fills in the `digit' field with the digit value.

           If the function returns 0, the code is not a number.
           Any other return value means the code is a number.

       uuccggeettnnuummbbeerr(())
           This is a compatibility function with John Cowan's
           "uctype" package.  It uses ucnumber_lookup().

       uuccggeettddiiggiitt(())
           This is a compatibility function with John Cowan's
           "uctype" package.  It uses ucdigit_lookup().

       uuccttoouuppppeerr(())
           This function returns the code unchanged if it is
           already upper case or has no upper case equivalent.
           Otherwise the upper case equivalent is returned.

       uuccttoolloowweerr(())
           This function returns the code unchanged if it is
           already lower case or has no lower case equivalent.
           Otherwise the lower case equivalent is returned.

       uuccttoottiittllee(())
           This function returns the code unchanged if it is
           already title case or has no title case equivalent.
           Otherwise the title case equivalent is returned.

       uucciisspprroopp(()) uucc88iisspprroopp(())
           This function is called by almost all of the ucis*()
           functions documented below. It stops testing after the
           first property match, unlike the function below which
           checks every property specified in the masks.

           The uc8isprop() version is the same as ucisprop() except
           it expects a UTF-8 encoded character.

           A non-zero is returned if the character matches at least
           oonnee of the properties. A zero is returned if the
           character matches none of the properties.

       uuccpprrooppss(()) uucc88pprrooppss(())
           This function does a property lookup as in the ucisprop()
           function above, but returns masks with the properties that
           matched set so the caller can use that information.

           Unlike the ucisprop() function above, this routine checks
           every property specified so it can return masks containing
           all the properties that matched. The routine above stops
           checking at the first match.

           The uc8props() version is the same as ucprops() except
           it expects a UTF-8 encoded character.

           A non-zero is return if at least one property matches.
           A zero is returned if the character has none of the
           specified properties.

       uucciissaallpphhaa(())
           Test if _c_o_d_e is an alpha character.

       uucciissaallnnuumm(())
           Test if _c_o_d_e is an alpha or digit character.

       uucciissddiiggiitt(())
           Test if _c_o_d_e is a digit character.

       uucciissccnnttrrll(())
           Test if _c_o_d_e is a control character.

       uucciissssppaaccee(())
           Test if _c_o_d_e is a space character.

       uucciissbbllaannkk(())
           Test if _c_o_d_e is a blank character.

       uucciissppuunncctt(())
           Test if _c_o_d_e is a punctuation character.

       uucciissggrraapphh(())
           Test if _c_o_d_e is a graphical (visible) character.

       uucciisspprriinntt(())
           Test if _c_o_d_e is a printable character.

       uucciissxxddiiggiitt(())
           Test if _c_o_d_e is a hexadecimal digit character.

       uucciissuuppppeerr(())
           Test if _c_o_d_e is an upper case character.

       uucciisslloowweerr(())
           Test if _c_o_d_e is a lower case character.

       uucciissttiittllee(())
           Test if _c_o_d_e is a title case character.

       uucchhaassccaassee(())
           Test if _c_o_d_e has upper, lower, or title variants.

       uucciissiissooccnnttrrll(())
           Is the character a C0 control character (< 32)?

       uucciissffmmttccnnttrrll(())
           Is the character a format control character?

       uucciissssyymmbbooll(())
           Is the character a symbol?

       uucciissnnuummbbeerr(())
           Is the character a number or digit?

       uucciissnnoonnssppaacciinngg(())
           Is the character non-spacing?

       uucciissooppeennppuunncctt(())
           Is the character an open/left punctuation (i.e. '[')

       uucciisscclloosseeppuunncctt(())
           Is the character an close/right punctuation (i.e. ']')

       uucciissiinniittiiaallppuunncctt(())
           Is the character an initial punctuation (i.e. U+2018 LEFT
           SINGLE QUOTATION MARK)

       uucciissffiinnaallppuunncctt(())
           Is the character a final punctuation (i.e. U+2019 RIGHT
           SINGLE QUOTATION MARK)

       uucciissccoommppoossiittee(())
           Can the character be decomposed into a set of other
           characters?

       uucciissqquuoottee(())
           Is the character one of the many quotation marks?

       uucciissssyymmmmeettrriicc(())
           Is the character one that has an opposite form
           (i.e. <>)

       uucciissmmiirrrroorriinngg(())
           Is the character mirroring (superset of symmetric)?

       uucciissnnoonnbbrreeaakkiinngg(())
           Is the character non-breaking (i.e. non-breaking
           space)?

       uucciissrrttll(())
           Does the character have strong right-to-left
           directionality (i.e. Arabic letters)?

       uucciissllttrr(())
           Does the character have strong left-to-right
           directionality (i.e. Latin letters)?

       uucciissssttrroonngg(())
           Does the character have strong directionality?

       uucciisswweeaakk(())
           Does the character have weak directionality
           (i.e. numbers)?

       uucciissnneeuuttrraall(())
           Does the character have neutral directionality
           (i.e. whitespace)?

       uucciisssseeppaarraattoorr(())
           Is the character a block or segment separator?

       uucciissllsseepp(())
           Is the character a line separator?

       uucciissppsseepp(())
           Is the character a paragraph separator?

       uucciissmmaarrkk(())
           Is the character a mark of some kind?

       uucciissnnssmmaarrkk(())
           Is the character a non-spacing mark?

       uucciissssppmmaarrkk(())
           Is the character a spacing mark?

       uucciissmmooddiiff(())
           Is the character a modifier letter?

       uucciissmmooddiiffssyymmbbooll(())
           Is the character a modifier symbol?

       uucciisslleettnnuumm(())
           Is the character a number represented by a letter?

       uucciissccoonnnneecctt(())
           Is the character connecting punctuation?

       uucciissddaasshh(())
           Is the character dash punctuation?

       uucciissmmaatthh(())
           Is the character a math character?

       uucciissccuurrrreennccyy(())
           Is the character a currency character?

       uucciisseenncclloossiinngg(())
           Is the character enclosing (i.e. enclosing box)?

       uucciisspprriivvaattee(())
           Is the character from the Private Use Area?

       uucciissssuurrrrooggaattee(())
           Is the character one of the surrogate codes?

       uucciissiiddeennttssttaarrtt(())
           Is the character a legal initial character of an identifier?

       uucciissiiddeennttppaarrtt(())
           Is the character a legal identifier character?

       uucciissddeeffiinneedd(())
           Is the character defined (appeared in one of the data
           files)?

       uucciissuunnddeeffiinneedd(())
           Is the character not defined (non-Unicode)?

       uucciisshhaann(())
           Is the character a Han ideograph?

       uucciisshhaanngguull(())
           Is the character a pre-composed Hangul syllable?

       uuccggeettuuttff88lloowweerr(())
           This retrieves the lower case form of a UTF-8 encoded character.
           If the character is already lower case or does not have a lower
           case form, the input pointer, _u_p_p_e_r is returned in _l_o_w_e_r.

       uuccttoouuttff88(())
           This function converts a UTF-32 character to UTF-8 encoding.

       uuccttoouuttff3322(())
           This function converts a UTF-8 encoded character to UTF-32.
           The second parameter, _b_y_t_e_s should be the number of bytes
           used by the UTF-8 character.


SSEEEE AALLSSOO
       ctype(3)


AACCKKNNOOWWLLEEDDGGMMEENNTTSS
       These are people who have helped with patches or alerted me about prob-
       lems.

       John Cowan <cowan@locke.ccil.org>
       Bob Verbrugge <bob_verbrugge@nl.compuware.com>
       Christophe Pierret <cpierret@businessobjects.com>
       Kent Johnson <kent@pondview.mv.com>
       Valeriy E. Ushakov <uwe@ptc.spbu.ru>
       Stig Venaas <Stig.Venaas@uninett.no>
       Hallvard B Furuseth <h.b.furuseth@usit.uio.no>


AAUUTTHHOORR
       Mark Leisher
       Computing Research Lab
       New Mexico State University
       Email: mleisher@crl.nmsu.edu



                                 21 March 2005                       ucdata(3)
